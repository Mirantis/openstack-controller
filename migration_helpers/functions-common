function info {
    local msg="[INFO]: $1"
    echo "$msg"
}

# Control Functions
# =================

# Prints backtrace info
# filename:lineno:function
# backtrace level
function backtrace {
    local level=$1
    local deep
    deep=$((${#BASH_SOURCE[@]} - 1))
    echo "[Call Trace]"
    while [ $level -le $deep ]; do
        echo "${BASH_SOURCE[$deep]}:${BASH_LINENO[$deep-1]}:${FUNCNAME[$deep-1]}"
        deep=$((deep - 1))
    done
}

# Prints line number and "message" then exits
# die $LINENO "message"
function die {
    local exitcode=$?
    set +o xtrace
    local line=$1; shift
    if [ $exitcode == 0 ]; then
        exitcode=1
    fi
    backtrace 2
    err $line "$*"
    # Give buffers a second to flush
    sleep 1
    exit $exitcode
}

# Checks an environment variable is not set or has length 0 OR if the
# exit code is non-zero and prints "message" and exits
# NOTE: env-var is the variable name without a '$'
# die_if_not_set $LINENO env-var "message"
function die_if_not_set {
    local exitcode=$?
    local xtrace
    xtrace=$(set +o | grep xtrace)
    set +o xtrace
    local line=$1; shift
    local evar=$1; shift
    if ! is_set $evar || [ $exitcode != 0 ]; then
        die $line "$*"
    fi
    $xtrace
}

function deprecated {
    local text=$1
    DEPRECATED_TEXT+="\n$text"
    echo "WARNING: $text" >&2
}

# Prints line number and "message" in error format
# err $LINENO "message"
function err {
    local exitcode=$?
    local xtrace
    xtrace=$(set +o | grep xtrace)
    set +o xtrace
    local msg="[ERROR] ${BASH_SOURCE[2]}:$1 $2"
    echo "$msg" 1>&2;
    if [[ -n ${LOGDIR} ]]; then
        echo "$msg" >> "${LOGDIR}/error.log"
    fi
    $xtrace
    return $exitcode
}

# Checks an environment variable is not set or has length 0 OR if the
# exit code is non-zero and prints "message"
# NOTE: env-var is the variable name without a '$'
# err_if_not_set $LINENO env-var "message"
function err_if_not_set {
    local exitcode=$?
    local xtrace
    xtrace=$(set +o | grep xtrace)
    set +o xtrace
    local line=$1; shift
    local evar=$1; shift
    if ! is_set $evar || [ $exitcode != 0 ]; then
        err $line "$*"
    fi
    $xtrace
    return $exitcode
}

# Exit after outputting a message about the distribution not being supported.
# exit_distro_not_supported [optional-string-telling-what-is-missing]
function exit_distro_not_supported {
    if [[ -z "$DISTRO" ]]; then
        GetDistro
    fi

    if [ $# -gt 0 ]; then
        die $LINENO "Support for $DISTRO is incomplete: no support for $@"
    else
        die $LINENO "Support for $DISTRO is incomplete."
    fi
}

# Test if the named environment variable is set and not zero length
# is_set env-var
function is_set {
    local var=\$"$1"
    eval "[ -n \"$var\" ]" # For ex.: sh -c "[ -n \"$var\" ]" would be better, but several exercises depends on this
}

function service_name_to_type {
    local service_name=$1
    case "$service_name" in
        "keystone" )
            echo "identity";;
        "heat" )
            echo "orchestration" ;;
        "glance" )
            echo "image" ;;
        "horizon" )
            echo "dashboard" ;;
        "nova" )
            echo "compute" ;;
        "octavia" )
            echo "load-balancer" ;;
        "cinder" )
            echo "block-storage" ;;
        "designate" )
            echo "dns" ;;
        "barbican" )
            echo "key-manager" ;;
        "neutron" )
            echo "networking" ;;
        *)
            exit 1 ;;
    esac
}

function get_service_subservices_internal_endpoints {
local service_name=$1
    case "$service_name" in
        "heat" )
            echo "heat-api heat-cfn" ;;
        "nova" )
            echo "nova-api placement-api" ;;
        "neutron" )
            echo "neutron-server" ;;
        *)
            echo "${service_name}-api" ;;
    esac
}

function get_service_subservices_public_endpoints {
local service_name=$1
    case "$service_name" in
        "heat" )
            echo "cloudformation heat" ;;
        "nova" )
            echo "novncproxy nova placement" ;;
        *)
            echo "${service_name}" ;;
    esac
}

function get_mcp2_external_ip {
  local service="$1"
  echo "$(kubectl -n openstack get services $service -o jsonpath='{.status.loadBalancer.ingress[0].ip}')"
}

function get_mcp2_internal_domain_name {
  echo $(kubectl -n openstack get ingress keystone -o yaml |grep '\- keystone.openstack.svc' | awk '{print $2}' | awk -F '.' '{print $4}')
}

function get_mcp2_public_domain_name {
  # TODO: get this info from osdpl
  echo "it.just.works"
}

function refresh_pillars {
  info "Refreshing pillars"
  timeout 600 salt '*' saltutil.refresh_pillar --timeout=600 > /dev/null || die $LINENO "Failed to refresh pillars"
  info "Pillars are refreshed"
}

function get_first_active_minion {
  local minion_id

  minion_id=$(salt $@ test.ping --out json | jq 'keys[0]' | head -1 | tr -d '"')
  echo $minion_id
}

function get_token_project {
  local token_project=$(salt -C 'I@keystone:server:role:primary' cmd.run '. /root/keystonercv3; openstack token issue -f value -c id -c project_id' --out json | jq '.[]' | tr -d '"')
  echo $token_project
}

function get_mcp1_public_endpoint {
  # TODO: unhardcode
  echo "https://10.13.0.80"
}

function get_mcp2_public_endpoint {
 local service_name=$1
 echo "https://${service_name}.$(get_mcp2_public_domain_name)"
}

function get_service_port {
  local service_name="$1"
  case "$service_name" in
      "keystone" )
          echo "5000";;
      "heat" )
          echo "8004" ;;
      "glance" )
          echo "9292" ;;
      "nova" )
          echo "8774" ;;
      "cinder" )
          echo "8776" ;;
      "neutron" )
          echo "9696" ;;
      *)
          exit 1 ;;
  esac
}

function get_check_endpoint {
  local service_name="$1"
  local project="$2"
  case "$service_name" in
      "keystone" )
          endpoint="v3/users";;
      "heat" )
          endpoint="v1/${project}/stacks" ;;
      "glance" )
          endpoint="v2/images" ;;
      "nova" )
          endpoint="v2.1/servers" ;;
      "cinder" )
          endpoint="v3/${project}/volumes/detail" ;;
      "neutron" )
          endpoint="v2.0/agents" ;;
      *)
          exit 1 ;;
  esac

  echo $endpoint
}

